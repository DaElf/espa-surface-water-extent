#! /usr/bin/env python
#
#Script to generate DSWE Version 2 Prototype 1 (V2_P1) Open Source Distribution Version 2 (distro_v3)
#
#
#
# *****************DEPENDENCIES*******************************************
# Python 2.7 64 bit, will not run on 32 bit Python
# GDAL 2.1+
# numpy 1.12
# lxml 3.7+
#
# *****************REVISION HISTORY*************************************** 
# Initiated on 08/13/16 by John W. Jones.
# Modified on 8/15/16 by Jacob Shermeyer to improve efficiency and activate
#  recoding scheme to produce the interpreted layer.
# Modified on 11/08/16 by John W. Jones to improve documentation as well as
#  revise the recode scheme to produce revised interpreted layer.
# Modified on 11/14/2016 to add slope masking.
# Modified on 1/18/2017 to enhance processing speed and remove a few unnecessary items
# Modified on 2/22/2017 to change to open source implementation (GDAL and numpy)
# Modified through March and April 2017 to add hillshade, modify slope masking, and update to the 
#   new SR naming convention
# Modified April 27-28 2017 to remove NLCD masking, remove redundant opening and closing of files,
#   generally improve performance, and change output bands to only those that will be distributed.
#   Note also, that the calculation of percent slope and hillshade layers are assumed to occur
#   outside of this code (in a pre-processing program).
#
# *****************INPUT FILE STRUCTURE***********************************
#  Required inputs for DSWE are LSRP data, the CFMask file generated by EROS, percent slope and hillshade
#   The input file directory should contain subdirectories in which all the geotiff formatted bands of a single
#  input scene have been extracted from their zip files and are stored in seperate folders.
#  Naming conventions of these files must not be edited in ANY way!  Use the default filenames as they were distributed by EROS.
#   04/28/2017
#  With this version, a percent slope file for the US is stored at the top level of the input directory. And hillshade data
#   calculated using the scene-specific solar geometry included in the mtl or xml file is included in
#   the same folder as each set of unzipped LSRP file associated with each scene. 
# This data derived from the DEM should be at 30m spatial resolution, snapped to your Landsat image and MUST be projected to match
#   the Landsat UTM zone.  It should be slighlty larger than your path/row.
# 
#
# *****************VARIABLE DECLARATIONS***********************************
#
# Input (data) variables
# BLUE = Landsat TM/ETM Band 1 or OLI Band 2
# GREEN = Landsat TM/ETM Band 2 or OLI Band 3 
# NIR = Landsat TM/ETM Band 4 or OLI Band 5
# SWIR1 = Landsat TM/ETM Band 5 or OLI Band 6 
# SWIR2 = Landsat TM/ETM Band 7 or OLI Band 7
# CF= Landsat Cfmask- Cloud, Cloud Shadow, and Snow Mask distributed with LSRP data
#
# *****************CALCULATED VARIABLES ON WHICH DECISIONS ARE MADE*********
#
# NDVI = Normalized Difference Vegetation Index
# MNDWI = Modified Normalized Difference Wetness Index
# MBSRV = Multiband Spectral Relationship Visible
# MBSRN = Multiband Spectral Relationship Near-infrared
# AWEsh = Automated raster Extent Shadow
# PSW1 = Partial Surface Water 1
# PSW2 = Partial Surface Water 2
#
# *****************OUTPUT INFORMATION*****************************
# Diagnostic layer- Layer indicating the combination of outcomes of the 5 water tests
# Interpreted layer- Interpretation of the diagnostic layer:
#     0= Non-Water, 1= High Confidence water, 2= Medium Confidence Water, 3= Potential Wetland, 4= Low Confidence Water or Wetland
# Masked Interpreted layer- Cloud, Snow, Slope, and Hillshade
# Mask Layer- A combination of all masks, combinations of these values indicate a pixel was masked multiple times:
# 0- No masks applied
# 2- CFMask Cloud Shadow Mask
# 3- CFMask Snow Mask
# 4- CFMask Cloud Mask
# 10- Slope Mask
# 20- Hillshade Mask
# 30- Slope and Hillshade Combination Mask

#############################################################################
# This prototype script is based on the original DSWE prototype.  It has been
# modified as follows:
#
# - works in a Linux instead of Windows environment
# - processes a single directory with all input and output files 
# - assumes the percent slope and hillshade files have been created by the
#   ESPA version of DSWE, already clipped to the image extent
# - uses collection 1 input (in particular, pixel QA instead of cfmask) 
# 
# It would typically be used to compare the results of the ESPA DSWE results
# to the original prototype results (to the extent that this modified version 
# is similar to the original).
#
# The expected sequence of operations is:
#
# 1. Run Surface Reflectance.
# 2. Build elevation band (build_elevation_band.py).
# 3. Run DSWE, using options to create percent slope, hillshade, and test files.
# 4. Convert ENVI to GeoTiff format (convert_espa_to_gtiff).
# 5. Run this script.
# 6. Compare output bands (diag, interp, interp_masked, and MaskLayer) to the
#    corresponding bands created by the ESPA version.
#############################################################################

#Imports
import numpy as np
import gdal
import os
import datetime
import glob
import sys
from lxml import etree


# ******************REQUIRED INPUT PARAMETERS********************************
WIGT = 0.124
AWGT = 0
AWE_param1 = 2.5
AWE_param2 = -1.5
AWE_param3 = -0.25
PSW1_MNDWI = -0.44
PSW1_NIR = 1500
PSW1_SWIR1 = 900
PSW1_NDVI = 0.7
PSW2_MNDWI = -0.5
PSW2_BLUE = 1000
PSW2_NIR = 2500
PSW2_SWIR1 = 3000
PSW2_SWIR2 = 1000

# Cutoff value for hillshade, values for hillshade range from 1-255, the lower
# the more shaded.
HS = 110


# Define the Pixel QA bit values 
PQA_FILL = 0                      # 1 
PQA_CLEAR = 1                     # 2 
PQA_WATER = 2                     # 4 
PQA_CLD_SHADOW = 3                # 8 
PQA_SNOW = 4                      # 16 
PQA_CLOUD = 5                     # 32 
PQA_CLOUD_CONF1 = 6               # 64 
PQA_CLOUD_CONF2 = 7               # 128 
PQA_CIRRUS_CONF1 = 8              # 256 
PQA_CIRRUS_CONF2 = 9              # 512 
PQA_TERRAIN_OCCL = 10             # 1024 
 
PQA_SINGLE_BIT = 0x01             # 00000001 
PQA_DOUBLE_BIT = 0x03             # 00000011 

PQA_LOW_CONF = 1                  # low confidence (01) 
PQA_MODERATE_CONF = 2             # moderate confidence (10) 
PQA_HIGH_CONF = 3                 # high confidence (11) 


# Get the input parameters.  
if len(sys.argv) != 3:
    print "Usage: linux_prototype.py <filename_prefix> <Landsat number>"
    sys.exit(1)
prefix = sys.argv[1]
LSnum = int(sys.argv[2])

# ***************************REQUIRED SLOPE INFORMATION*************************
# Slope file you have created must have the word "percent_slope" in the 
# filename and be a .tif image.
#


# Set the overwrite & output environment
driver = gdal.GetDriverByName("GTiff")

# Landsat 4, 5, and 7
if LSnum <= 7 :
    Blue = prefix + '_sr_band1.tif'
    Green = prefix + '_sr_band2.tif'
    Red = prefix + '_sr_band3.tif'
    NIR = prefix + '_sr_band4.tif'
    SWIR1 = prefix + '_sr_band5.tif'
    SWIR2 = prefix + '_sr_band7.tif'
# Landsat 8
elif LSnum == 8:
    Blue = prefix + '_sr_band2.tif'
    Green = prefix + '_sr_band3.tif'
    Red = prefix + '_sr_band4.tif'
    NIR = prefix + '_sr_band5.tif'
    SWIR1 = prefix + '_sr_band6.tif'
    SWIR2 = prefix + '_sr_band7.tif'

Pixel_qa = prefix + '_pixel_qa.tif'
Hillshade = prefix + '_hillshade.tif'
Percent_slope = prefix + '_percent_slope.tif'
out_name = "DSWE_PROTOTYPE"

# Perform Water Index (MNDWI only based) Test- Working
GreenB = gdal.Open(Green)
SWIR1B = gdal.Open(SWIR1)
geo = GreenB.GetGeoTransform()
proj = GreenB.GetProjection()
GreenB= GreenB.GetRasterBand(1).ReadAsArray()
SWIR1B= SWIR1B.GetRasterBand(1).ReadAsArray()
shape = GreenB.shape
MNDWI = ((GreenB - SWIR1B) /np.float32(GreenB + SWIR1B))
con_MNDWI = MNDWI.copy()
con_MNDWI[con_MNDWI <= WIGT] = 0
con_MNDWI[con_MNDWI > WIGT] = 1
con_MNDWI = np.int8(con_MNDWI)

# Perform MBSR Test- Working
RedB = gdal.Open(Red)
RedB = RedB.GetRasterBand(1).ReadAsArray()
# I'm making these float because the upper limit for int16 can be exceeded when
# GreenB and RedB are added (e.g.: 20,000 + 20,000) 
MBSV = (np.float32(GreenB) + np.float32(RedB))
NIRB = gdal.Open(NIR)
NIRB = NIRB.GetRasterBand(1).ReadAsArray()
MBSRN = (np.float32(NIRB) + np.float32(SWIR1B))
con_MBSR = np.zeros(shape)
con_MBSR[MBSV > MBSRN] = 10
con_MBSR = np.int8(con_MBSR)
del MBSV

#Calculate AWEsh values- working
con_AWEsh = (np.float32(GreenB) * AWE_param1)
con_AWEsh += (np.float32(MBSRN) * AWE_param2)
MBSRN_out = driver.Create( "MBSRN.tif", shape[1], shape[0], 1, gdal.GDT_UInt32)
MBSRN_out.SetGeoTransform(geo)
MBSRN_out.SetProjection(proj) 
MBSRN_out.GetRasterBand(1).WriteArray(MBSRN)
MBSRN_out = None
SWIR2B = gdal.Open(SWIR2)
SWIR2B = SWIR2B.GetRasterBand(1).ReadAsArray()
con_AWEsh += (np.float32(SWIR2B) * AWE_param3)
BlueB = gdal.Open(Blue)
BlueB = BlueB.GetRasterBand(1).ReadAsArray()
con_AWEsh += np.float32(BlueB)
con_AWEsh[con_AWEsh > 0] = 100
con_AWEsh[con_AWEsh <= 0] = 0
con_AWEsh=np.int8(con_AWEsh)

# Perform Partial Surface Water test 1 (PSW1)-working
con_PSW1_MNDWI = ((GreenB - SWIR1B) / np.float32(GreenB + SWIR1B))

con_PSW1_MNDWI[con_PSW1_MNDWI > PSW1_MNDWI] = 1
con_PSW1_MNDWI[con_PSW1_MNDWI <= PSW1_MNDWI] = 0
con_PSW1_MNDWI=np.int8(con_PSW1_MNDWI)
NIRB[NIRB < PSW1_NIR] = 1
NIRB[NIRB >= PSW1_NIR] = 0
PSW1 = np.int8(con_PSW1_MNDWI) * np.int8(NIRB)
PSW1_SWIR1B = SWIR1B.copy()
PSW1_SWIR1B[PSW1_SWIR1B < PSW1_SWIR1] = 1
PSW1_SWIR1B[PSW1_SWIR1B >= PSW1_SWIR1] = 0
PSW1 = np.int8(PSW1) * np.int8(PSW1_SWIR1B)
del PSW1_SWIR1B

# Calculate NDVI
NIRB = gdal.Open(NIR)
NIRB = NIRB.GetRasterBand(1).ReadAsArray()
NDVI = ((NIRB - RedB) /np.float32(NIRB + RedB))
con_NDVI = np.zeros(shape)
con_NDVI[NDVI < PSW1_NDVI] = 1
PSW1 = np.int16(PSW1) * np.int16(con_NDVI) * 1000

#Perform PSW2 test- working
con_PSW2_MNDWI = ((GreenB - SWIR1B) / np.float32(GreenB + SWIR1B))
con_PSW2_MNDWI[con_PSW2_MNDWI > PSW2_MNDWI] = 1
con_PSW2_MNDWI[con_PSW2_MNDWI <= PSW2_MNDWI] = 0
con_PSW2_MNDWI = np.int8(con_PSW2_MNDWI)
BlueB[BlueB < PSW2_BLUE] = 1
BlueB[BlueB >= PSW2_BLUE] = 0
BlueB = np.int8(BlueB) 
NIRB[NIRB < PSW2_NIR] = 1
NIRB[NIRB >= PSW2_NIR] = 0
NIRB = np.int8(NIRB)
SWIR1B[SWIR1B < PSW2_SWIR1] = 1
SWIR1B[SWIR1B >= PSW2_SWIR1] = 0
SWIR1B = np.int8(SWIR1B) 
SWIR2B[SWIR2B < PSW2_SWIR2] = 1
SWIR2B[SWIR2B >= PSW2_SWIR2] = 0
SWIR2B = np.int8(SWIR2B)
PSW2 = con_PSW2_MNDWI * BlueB * NIRB * SWIR1B *  SWIR2B * 10000

# Cleanup
del GreenB, SWIR1B, MNDWI, RedB, NIRB, MBSRN, SWIR2B, BlueB, con_PSW1_MNDWI, con_NDVI, con_PSW2_MNDWI
diagmap= con_MNDWI + con_MBSR + con_AWEsh + PSW1 + PSW2
del con_MNDWI, con_MBSR, con_AWEsh, PSW1, PSW2

# Open mask. 

hillshadeB = gdal.Open(Hillshade)
hillshade = hillshadeB.GetRasterBand(1).ReadAsArray()
hillshade[hillshade <= HS] = 0
hillshade[hillshade > HS] = 1

# Calculate our unmasked diagnostic map
pixel_qaB = gdal.Open(Pixel_qa)
pixel_qa = pixel_qaB.GetRasterBand(1).ReadAsArray()
diagoutput = out_name + "_diag" + prefix + ".tif"

# This looks for pixel QA fill locations.
diagmap[np.where((np.bitwise_and(np.right_shift(pixel_qa, PQA_FILL), 
    PQA_SINGLE_BIT) == 1))] = -9999
diagmap_out = driver.Create(diagoutput, shape[1], shape[0], 1, gdal.GDT_Int16)
diagmap_out.SetGeoTransform(geo)
diagmap_out.SetProjection(proj)
diagmap_out.GetRasterBand(1).WriteArray(diagmap)
diagmap_out.GetRasterBand(1).SetNoDataValue(-9999)

# Output unmasked interpreted map
interpoutput = out_name + "_interp" + prefix + ".tif"
interpmap = diagmap.copy()
interpmap[np.where((diagmap == 0) | (diagmap == 1) | (diagmap == 10) | (diagmap == 100) | (diagmap == 1000))] = 0
interpmap[np.where((diagmap == 1111) | (diagmap == 10111) | (diagmap == 11011) | (diagmap == 11101) | (diagmap == 11110) | (diagmap == 11111)) ] = 1
interpmap[np.where((diagmap == 111) | (diagmap == 1011) | (diagmap == 1101) | (diagmap == 1110) | (diagmap == 10011) | (diagmap == 10101) | (diagmap == 10110) | (diagmap == 11001) | (diagmap == 11010) | (diagmap == 11100)) ] = 2
interpmap[np.where((diagmap == 11000)) ] = 3
interpmap[np.where((diagmap == 11) | (diagmap == 101) | (diagmap == 110) | (diagmap == 1001) | (diagmap == 1010) | (diagmap == 1100) | (diagmap == 10000) | (diagmap == 10001) | (diagmap == 10010) | (diagmap == 10100)) ] = 4
interpmap[np.where((diagmap == -9999)) ] = 255
interpmap_out = driver.Create( interpoutput, shape[1], shape[0], 1, gdal.GDT_Byte)
interpmap_out.SetGeoTransform(geo)
interpmap_out.SetProjection(proj)
interpmap_out.GetRasterBand(1).WriteArray(interpmap)
interpmap_out.GetRasterBand(1).SetNoDataValue(255)

# Terrain Correction, here we are simply recoding slopes >=x degrees to PS 
# (specified above), which will be reclassified as non-water.
# Mask interpreted map using the slope file
perslpB = gdal.Open(Percent_slope)
perslp = perslpB.GetRasterBand(1).ReadAsArray()
interpmap_copy = interpmap.copy()
interpmap[np.where((perslp >= 30) & (interpmap == 2))] = 0
interpmap[np.where((perslp >= 20) & (interpmap == 3))] = 0
interpmap[np.where((perslp >= 10) & (interpmap == 4))] = 0
interpmap[np.where((perslp >= 30) & (interpmap == 1))] = 0
interpmap_masked = interpmap * hillshade

# Cloud and snow masking and outputing masked interpreted layer
interpmaskoutput = out_name + "_interp_masked" + prefix + ".tif"
interpmap_masked = interpmap_masked.copy()
# This finds locations where pixel QA is fill.
interpmap_masked[np.where((np.bitwise_and(np.right_shift(pixel_qa, PQA_FILL), 
    PQA_SINGLE_BIT) == 1))] = 255
# This finds locations where pixel QA is cloud shadow, snow, or cloud.
interpmap_masked[np.where((np.bitwise_and(np.right_shift(pixel_qa, 
    PQA_CLD_SHADOW), PQA_SINGLE_BIT) == 1))] = 9
interpmap_masked[np.where((np.bitwise_and(np.right_shift(pixel_qa, PQA_SNOW), 
    PQA_SINGLE_BIT) == 1))] = 9
interpmap_masked[np.where((np.bitwise_and(np.right_shift(pixel_qa, PQA_CLOUD), 
    PQA_SINGLE_BIT) == 1))] = 9
# Simulate the cloud, snow, and shadow part of cfmask, added together. 
cfmask_css = interpmap.copy()
cfmask_css.fill(0)
cfmask_css[np.where((np.bitwise_and(np.right_shift(pixel_qa, 
    PQA_CLD_SHADOW), PQA_SINGLE_BIT) == 1))] += 2
cfmask_css[np.where((np.bitwise_and(np.right_shift(pixel_qa, PQA_SNOW), 
    PQA_SINGLE_BIT) == 1))] += 3
cfmask_css[np.where((np.bitwise_and(np.right_shift(pixel_qa, PQA_CLOUD), 
    PQA_SINGLE_BIT) == 1))] += 4

interpmap_masked_out = driver.Create( interpmaskoutput, shape[1], shape[0], 1, gdal.GDT_Byte)
interpmap_masked_out.SetGeoTransform(geo)
interpmap_masked_out.SetProjection(proj)
interpmap_masked_out.GetRasterBand(1).WriteArray(interpmap_masked)
interpmap_masked_out.GetRasterBand(1).SetNoDataValue(255)
del interpmap_masked_out
del diagmap
del interpmap

# Create a full mask layer
perslp[np.where((perslp < 10) & (interpmap_copy == 4)) ] = 0
perslp[np.where((perslp < 20) & (interpmap_copy == 3)) ] = 0
perslp[np.where((perslp < 30) & (interpmap_copy == 2)) ] = 0
perslp[np.where((perslp < 30) & (interpmap_copy == 1)) ] = 0
perslp[np.where((perslp >= 10) & (interpmap_copy == 4)) ] = 10
perslp[np.where((perslp >= 20) & (interpmap_copy == 3)) ] = 10
perslp[np.where((perslp >= 30) & (interpmap_copy == 2)) ] = 10
perslp[np.where((perslp >= 30) & (interpmap_copy == 1)) ] = 10
perslp[np.where((interpmap_copy == 0))] = 0
hillshade[np.where((hillshade == 0)) ] = 20
hillshade[np.where((hillshade == 1)) ] = 0
MaskLayer = cfmask_css + perslp + hillshade
MaskLayerOut = out_name + "_MaskLayer" + prefix + ".tif"
# This finds locations where pixel QA is fill.
MaskLayer[np.where((np.bitwise_and(np.right_shift(pixel_qa, PQA_FILL), 
    PQA_SINGLE_BIT) == 1))] = 255
MaskLayer_Output = driver.Create(MaskLayerOut, shape[1], shape[0], 1, gdal.GDT_Byte)
MaskLayer_Output.SetGeoTransform(geo)
MaskLayer_Output.SetProjection(proj)
MaskLayer_Output.GetRasterBand(1).WriteArray(MaskLayer)
MaskLayer_Output.GetRasterBand(1).SetNoDataValue(255)

# Cleanup
del hillshade, MaskLayer, pixel_qa, MaskLayerOut, MaskLayer_Output, diagoutput
del diagmap_out, interpmap_masked, interpmap_out, interpmaskoutput, interpoutput, perslp

